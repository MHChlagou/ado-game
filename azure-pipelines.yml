# Azure DevOps Pipeline for ADO Game React Application
# This pipeline builds and deploys the React app using Docker

trigger:
- main
- develop

pool:
  name: 'grenoble'
  demands:
  - agent.name -equals MyLinuxAgent

parameters:
- name: deploymentPath
  displayName: 'Deployment Path'
  type: string
  default: '/opt/ado-game'
- name: imageName
  displayName: 'Docker Image Name'
  type: string
  default: 'ado-game'
- name: imageTag
  displayName: 'Docker Image Tag'
  type: string
  default: '$(Build.BuildNumber)'

variables:
  artifactName: 'ado-game-build'

stages:
- stage: Build
  displayName: 'Build Stage'
  jobs:
  - job: BuildJob
    displayName: 'Build Docker Image'
    steps:
    - script: |
        docker build -t ${{ parameters.imageName }}:${{ parameters.imageTag }} -t ${{ parameters.imageName }}:latest .
      displayName: 'Build Docker Image'
      
    - script: |
        docker save ${{ parameters.imageName }}:${{ parameters.imageTag }} -o $(Build.ArtifactStagingDirectory)/${{ parameters.imageName }}-${{ parameters.imageTag }}.tar
      displayName: 'Save Docker Image'
        
    - task: PublishBuildArtifacts@1
      displayName: 'Publish Docker Image Artifact'
      inputs:
        pathToPublish: '$(Build.ArtifactStagingDirectory)'
        artifactName: '$(artifactName)'
        publishLocation: 'Container'

- stage: Deploy
  displayName: 'Deploy Stage'
  dependsOn: Build
  condition: succeeded()
  jobs:
  - job: DeployJob
    displayName: 'Deploy with Docker Compose'
    steps:
    - task: DownloadBuildArtifacts@0
      displayName: 'Download Build Artifacts'
      inputs:
        buildType: 'current'
        downloadType: 'single'
        artifactName: '$(artifactName)'
        downloadPath: '$(System.ArtifactsDirectory)'
        
    - task: SSH@0
      displayName: 'Create Deployment Directory'
      inputs:
        sshEndpoint: 'deployment-server'
        runOptions: 'inline'
        inline: |
          mkdir -p ${{ parameters.deploymentPath }}
        
    - task: CopyFilesOverSSH@0
      displayName: 'Copy Docker Compose and Image to Remote Server'
      inputs:
        sshEndpoint: 'deployment-server'
        sourceFolder: '$(Build.SourcesDirectory)'
        contents: 'docker-compose.yml'
        targetFolder: '${{ parameters.deploymentPath }}'
        
    - task: CopyFilesOverSSH@0
      displayName: 'Copy Docker Image to Remote Server'
      inputs:
        sshEndpoint: 'deployment-server'
        sourceFolder: '$(System.ArtifactsDirectory)/$(artifactName)'
        contents: '*.tar'
        targetFolder: '${{ parameters.deploymentPath }}'
        
    - task: SSH@0
      displayName: 'Deploy with Docker Compose'
      inputs:
        sshEndpoint: 'deployment-server'
        runOptions: 'inline'
        inline: |
          cd ${{ parameters.deploymentPath }}
          
          # Load Docker image
          docker load -i ${{ parameters.imageName }}-${{ parameters.imageTag }}.tar
          
          # Stop existing containers (redirect stderr to avoid false error messages)
          docker compose down --remove-orphans 2>&1 || true
 
          # Set environment variables for docker-compose
          export IMAGE_NAME=${{ parameters.imageName }}
          export IMAGE_TAG=${{ parameters.imageTag }}
          
          # Start new containers (redirect stderr to avoid false error messages)
          docker compose up -d 2>&1 || true
          
          # Wait for container to be ready
          echo "Waiting for container to start..."
          sleep 10
          
          # Check container status
          docker compose ps
          
          echo "Deployment completed successfully!"

- stage: HealthCheck
  displayName: 'Health Check'
  dependsOn: Deploy
  condition: succeeded()
  jobs:
  - job: HealthCheckJob
    displayName: 'Verify Deployment'
    steps:
    - task: SSH@0
      displayName: 'Check Application Health'
      inputs:
        sshEndpoint: 'deployment-server'
        runOptions: 'inline'
        inline: |
          # Health check using curl on remote server
          maxAttempts=10
          attempt=1
          success=false
          
          while [ $attempt -le $maxAttempts ] && [ "$success" = false ]; do
              echo "Health check attempt $attempt of $maxAttempts"
              
              # Check container health first
              if docker compose -f ${{ parameters.deploymentPath }}/docker-compose.yml ps | grep -q "Up"; then
                  echo "Container is running, checking HTTP response..."
                  
                  if response=$(curl -s -o /dev/null -w "%{http_code}" --connect-timeout 10 "http://localhost/"); then
                      if [ "$response" = "200" ]; then
                          echo "‚úÖ Application is responding successfully!"
                          success=true
                      else
                          echo "‚ùå Unexpected status code: $response"
                      fi
                  else
                      echo "‚ùå Health check failed: curl command failed"
                  fi
              else
                  echo "‚ùå Container is not running properly"
              fi
              
              if [ "$success" = false ]; then
                  if [ $attempt -eq $maxAttempts ]; then
                      echo "Health check failed after $maxAttempts attempts"
                      echo "Container logs:"
                      docker compose -f ${{ parameters.deploymentPath }}/docker-compose.yml logs --tail=50
                      exit 1
                  fi
                  sleep 15
                  attempt=$((attempt + 1))
              fi
          done
          
          if [ "$success" = true ]; then
              echo "üéâ Deployment verification completed successfully!"
              echo "Application is available at: http://localhost"
          fi
